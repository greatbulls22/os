Lab 07: Process Management
Task 1: The Process Hierarchy
Goal: Create a child, have it calculate, and ensure the parent waits.


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    printf("I am Parent, PID: %d\n", getpid());

    pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (pid == 0) {
        // --- Child Process ---
        printf("I am Child, PID: %d, Parent PID: %d\n", getpid(), getppid());
        
        // Perform calculation: Print first 5 even numbers
        printf("Child calculating: ");
        for (int i = 1; i <= 5; i++) {
            printf("%d ", i * 2);
        }
        printf("\n");
        
        exit(0); // Important: Child must exit here
    } else {
        // --- Parent Process ---
        wait(NULL); // Blocks here until child exits
        printf("Child has terminated. Parent exiting now.\n");
    }

    return 0;
}


Task 2: Chain of Forks (A -> B -> C)
Goal: Create a 3-level process chain.


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pidB, pidC;

    printf("Process A (Grandparent): PID %d\n", getpid());

    pidB = fork();

    if (pidB == 0) {
        // --- Process B ---
        printf("Process B (Parent): PID %d, Parent PID %d\n", getpid(), getppid());
        
        pidC = fork();
        
        if (pidC == 0) {
            // --- Process C ---
            printf("Process C (Child): PID %d, Parent PID %d\n", getpid(), getppid());
            exit(0);
        } else {
            wait(NULL); // B waits for C
            printf("Process B: My child C has finished.\n");
            exit(0);
        }
    } else {
        // --- Process A ---
        wait(NULL); // A waits for B
        printf("Process A: My child B has finished.\n");
    }

    return 0;
}


Lab 08: Exec & Zombies
Task 3: Shell Simulator (execvp)
Goal: Replace the child process with the ls -l command.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Child Process
        printf("Child: Executing 'ls -l' now...\n");
        
        // Arguments array must end with NULL
        char *args[] = {"ls", "-l", NULL};
        
        // Replace current process image
        execvp(args[0], args);
        
        // This line only prints if execvp fails
        perror("execvp failed");
        exit(1);
    } else {
        // Parent Process
        wait(NULL);
        printf("Parent: Command executed successfully.\n");
    }

    return 0;
}


Task 4: Creating a Zombie Process
Goal: Create a process state where the child is dead but the parent hasn't collected it yet.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Child exits immediately
        printf("Child (PID: %d) exiting...\n", getpid());
        exit(0); 
    } else {
        // Parent sleeps without calling wait()
        printf("Parent (PID: %d) sleeping for 10 seconds.\n", getpid());
        printf("Quickly run 'ps -l' in another terminal to see the <defunct> Zombie.\n");
        sleep(10);
        printf("Parent woke up. (Zombie will be cleaned up when I exit)\n");
    }

    return 0;
}


Lab 09: Pthreads Introduction
Task 5: Parallel Array Sum
Goal: Sum an array using 2 threads. Compile with: gcc task5.c -lpthread -o task5

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define SIZE 10

// Struct to pass arguments to threads
typedef struct {
    int start_index;
    int end_index;
    int *arr;
} ThreadData;

int numbers[SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

void *sum_array(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    int *partial_sum = malloc(sizeof(int)); // Allocate memory for result
    *partial_sum = 0;

    for (int i = data->start_index; i <= data->end_index; i++) {
        *partial_sum += data->arr[i];
    }
    
    return (void *)partial_sum;
}

int main() {
    pthread_t t1, t2;
    ThreadData d1, d2;

    // Setup Thread 1 (Indices 0-4)
    d1.start_index = 0; 
    d1.end_index = 4;   
    d1.arr = numbers;

    // Setup Thread 2 (Indices 5-9)
    d2.start_index = 5; 
    d2.end_index = 9;   
    d2.arr = numbers;

    pthread_create(&t1, NULL, sum_array, &d1);
    pthread_create(&t2, NULL, sum_array, &d2);

    void *res1;
    void *res2;

    pthread_join(t1, &res1);
    pthread_join(t2, &res2);

    int total = *(int*)res1 + *(int*)res2;
    printf("Sum 1: %d\nSum 2: %d\nTotal Sum: %d\n", *(int*)res1, *(int*)res2, total);

    free(res1);
    free(res2);
    return 0;
}

Lab 10: Synchronization (Mutex)
Task 7: Safe Counter
Goal: Prevent race conditions when incrementing a shared counter. Compile with: gcc task7.c -lpthread -o task7

#include <stdio.h>
#include <pthread.h>

#define ITERATIONS 1000000

int counter = 0;
pthread_mutex_t lock;

void *worker(void *arg) {
    for (int i = 0; i < ITERATIONS; i++) {
        // Critical Section Start
        pthread_mutex_lock(&lock);
        counter++;
        pthread_mutex_unlock(&lock);
        // Critical Section End
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;

    // Initialize Mutex
    if (pthread_mutex_init(&lock, NULL) != 0) {
        printf("Mutex init failed\n");
        return 1;
    }

    pthread_create(&t1, NULL, worker, NULL);
    pthread_create(&t2, NULL, worker, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&lock);

    printf("Final Counter: %d (Expected: 2000000)\n", counter);
    return 0;
}

Lab 11: Condition Variables & Barriers
Task 8: Barrier Synchronization
Goal: Make 3 threads wait for each other before proceeding. Compile with: gcc task8.c -lpthread -o task8

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define NUM_THREADS 3

pthread_barrier_t barrier;

void *thread_func(void *arg) {
    int id = *(int *)arg;
    int sleep_time = rand() % 3 + 1; // Sleep 1-3 seconds

    printf("Thread %d sleeping for %d seconds...\n", id, sleep_time);
    sleep(sleep_time);

    printf("Thread %d reached the barrier.\n", id);
    
    // --- WAIT HERE ---
    pthread_barrier_wait(&barrier);
    
    printf("Thread %d passed the barrier!\n", id);
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int ids[NUM_THREADS];

    // Initialize Barrier for 3 threads
    pthread_barrier_init(&barrier, NULL, NUM_THREADS);

    for (int i = 0; i < NUM_THREADS; i++) {
        ids[i] = i;
        pthread_create(&threads[i], NULL, thread_func, &ids[i]);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_barrier_destroy(&barrier);
    return 0;
}


Task 9: Producer-Consumer (Condition Variable)
Goal: Use signals to coordinate a main thread and a worker. Compile with: gcc task9.c -lpthread -o task9

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int buffer = 0; // Shared resource
pthread_mutex_t mtx;
pthread_cond_t cond;

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&mtx);
        
        // Wait while buffer is empty (0)
        while (buffer == 0) {
            pthread_cond_wait(&cond, &mtx); // Releases lock and sleeps
        }
        
        // Wake up!
        if (buffer == -1) { // Exit signal
            pthread_mutex_unlock(&mtx);
            break;
        }

        printf("Consumer: Received value %d. Processing...\n", buffer);
        buffer = 0; // Reset buffer
        
        pthread_mutex_unlock(&mtx);
    }
    return NULL;
}

int main() {
    pthread_t t;
    
    pthread_mutex_init(&mtx, NULL);
    pthread_cond_init(&cond, NULL);
    
    pthread_create(&t, NULL, consumer, NULL);

    int input;
    while (1) {
        printf("Producer: Enter a number (-1 to quit): ");
        scanf("%d", &input);

        pthread_mutex_lock(&mtx);
        
        buffer = input;
        pthread_cond_signal(&cond); // Wake up the consumer
        
        pthread_mutex_unlock(&mtx);

        if (input == -1) break;
        sleep(1); // Small delay to let consumer print
    }

    pthread_join(t, NULL);
    
    pthread_mutex_destroy(&mtx);
    pthread_cond_destroy(&cond);
    return 0;
}


// create a thread-safe banking system.

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the number of operations each thread will perform
#define TRANSACTIONS 100000 
#define NUM_THREADS 2

// Shared Resource: The Bank Account Balance
int balance = 0; 

// Mutex variable to protect the shared resource
pthread_mutex_t balance_mutex; 

// Thread function for Incrementing (Depositing)
void *deposit(void *thread_id) {
    long tid = (long)thread_id;
    
    for (int i = 0; i < TRANSACTIONS; i++) {
        // LOCK the critical section before accessing shared resource [cite: 29, 34]
        pthread_mutex_lock(&balance_mutex);
        
        balance++; // Critical Section: Modifying shared variable
        
        // UNLOCK after finishing to allow other threads access [cite: 29, 34]
        pthread_mutex_unlock(&balance_mutex);
    }
    
    printf("Deposit Thread %ld finished.\n", tid);
    pthread_exit(NULL);
}

// Thread function for Decrementing (Withdrawing)
void *withdraw(void *thread_id) {
    long tid = (long)thread_id;
    
    for (int i = 0; i < TRANSACTIONS; i++) {
        // LOCK the critical section 
        pthread_mutex_lock(&balance_mutex);
        
        balance--; // Critical Section
        
        // UNLOCK the critical section 
        pthread_mutex_unlock(&balance_mutex);
    }
    
    printf("Withdraw Thread %ld finished.\n", tid);
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    long t;
    int rc;

    // 1. Initialize the Mutex 
    pthread_mutex_init(&balance_mutex, NULL);

    printf("Initial Balance: %d\n", balance);

    // 2. Create Threads 
    // Creating one thread for deposit and one for withdraw
    printf("Creating threads...\n");
    
    // Thread 0 performs Deposit
    rc = pthread_create(&threads[0], NULL, deposit, (void *)0);
    if (rc) {
        printf("Error: unable to create thread, %d\n", rc);
        exit(-1);
    }

    // Thread 1 performs Withdraw
    rc = pthread_create(&threads[1], NULL, withdraw, (void *)1);
    if (rc) {
        printf("Error: unable to create thread, %d\n", rc);
        exit(-1);
    }

    // 3. Wait for threads to finish using pthread_join 
    for (t = 0; t < NUM_THREADS; t++) {
        pthread_join(threads[t], NULL);
    }

    // 4. Destroy the Mutex 
    pthread_mutex_destroy(&balance_mutex);

    // The final balance should be 0 if synchronization worked correctly
    // (100,000 increments - 100,000 decrements = 0)
    printf("Final Balance: %d\n", balance);

    pthread_exit(NULL);
}


Task 1: Simple Wait (Signal)
Concept: The main thread needs to pause until the worker thread signals that it is done. We use a Condition Variable (cond) and a flag (done).


#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h> // Required for time()

static int result = 0;

// Synchronization primitives
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int done = 0; // Flag to indicate work is finished

void *tfunc(void *arg) {

    // do some work
    int r = rand()%10;
    sleep(r);

    // Lock, update result, set flag, signal, and unlock
    pthread_mutex_lock(&mutex);
    result = 7;
    done = 1; 
    pthread_cond_signal(&cond); // Signal main thread
    pthread_mutex_unlock(&mutex);

    printf("thread: produced result.\n");
    return NULL;
}

int main() {
    srand(time(NULL));

    printf("main: creating thread.\n");
    pthread_t tid;
    pthread_create(&tid, NULL, tfunc, NULL);

    // main should wait here for the thread
    pthread_mutex_lock(&mutex);
    while (done == 0) { // Check flag to handle spurious wakeups
        pthread_cond_wait(&cond, &mutex);
    }
    pthread_mutex_unlock(&mutex);

    // use the thread result
    printf("main: result = %d\n", result);

    pthread_join(tid, NULL);
    return 0;
}


Task 2: Ordered Execution (Turn-Taking)
Concept: We need to force an order (0, 1, 2...). We use a shared counter turn. Each thread waits until turn equals its own rank, does its work, increments turn, and then broadcasts to wake up the next thread (and eventually main).

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#define NUMTHREADS 10

// Synchronization primitives
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int turn = 0; // Tracks whose turn it is (starts at 0)

void *tfunc(void *arg) {

    int rank = (int)(long) arg; // Cast to long first to avoid warnings

    // do some work
    sleep(rand()%5);

    pthread_mutex_lock(&mutex);
    
    // Wait until it is my turn
    while (turn != rank) {
        pthread_cond_wait(&cond, &mutex);
    }

    printf("thread: my turn!, my rank is %d.\n", rank);
    
    // Pass turn to the next rank
    turn++;
    
    // Wake up all threads (next rank worker and main) to check the turn
    pthread_cond_broadcast(&cond);
    
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main() {
    srand(time(NULL));

    printf("main: creating threads.\n");
    pthread_t tid[NUMTHREADS];
    for(int i=0; i<NUMTHREADS; i++)
        pthread_create(&tid[i], NULL, tfunc, (void *)(long)i);

    // main should wait here for the thread
    pthread_mutex_lock(&mutex);
    
    // Main waits until all threads (0 to NUMTHREADS-1) have finished
    while (turn < NUMTHREADS) {
        pthread_cond_wait(&cond, &mutex);
    }
    pthread_mutex_unlock(&mutex);

    printf("main: i hope all threads are finished by now!!\n");

    for(int i=0; i<NUMTHREADS; i++)
        pthread_join(tid[i], NULL);
    return 0;
}


Task 3: Producer-Consumer
Concept: This uses a Bounded Buffer. Producers wait if the buffer is full; Consumers wait if the buffer is empty. We track total_produced to ensure we stop exactly after NVALUES.

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

#define NPRODUCERS 10
#define NCONSUMERS 5
#define BUFFSIZE 10
#define NVALUES 1000

int BUFFER[BUFFSIZE];

// Buffer State
int count = 0; // Items currently in buffer
int in = 0;    // Index to put next item
int out = 0;   // Index to take next item

// Global Progress Tracking
int total_produced = 0;
int total_consumed = 0;

// Synchronization
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond_full = PTHREAD_COND_INITIALIZER;  // Wait here if buffer is full
pthread_cond_t cond_empty = PTHREAD_COND_INITIALIZER; // Wait here if buffer is empty

void *producer(void *arg) {
    while (1) {
        pthread_mutex_lock(&mutex);

        // Stop if we have produced enough
        if (total_produced >= NVALUES) {
            pthread_mutex_unlock(&mutex);
            break;
        }

        // Wait if buffer is full
        while (count == BUFFSIZE) {
            pthread_cond_wait(&cond_full, &mutex);
        }
        
        // Double check limits after waking up
        if (total_produced >= NVALUES) {
            pthread_mutex_unlock(&mutex);
            break;
        }

        // Produce Item
        BUFFER[in] = total_produced;
        in = (in + 1) % BUFFSIZE;
        count++;
        total_produced++;

        // Signal consumers that data is available
        pthread_cond_signal(&cond_empty);
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&mutex);

        // Wait if buffer is empty
        while (count == 0) {
            // If empty AND production is finished, we are done
            if (total_produced >= NVALUES) {
                pthread_mutex_unlock(&mutex);
                pthread_cond_broadcast(&cond_empty); // Wake other consumers to exit
                return NULL;
            }
            pthread_cond_wait(&cond_empty, &mutex);
        }

        // Consume Item
        int val = BUFFER[out];
        out = (out + 1) % BUFFSIZE;
        count--;
        total_consumed++;

        // Signal producers that space is available
        pthread_cond_signal(&cond_full);
        pthread_mutex_unlock(&mutex);
        
        // (Optional) Print progress occasionally
        // printf("Consumed: %d\n", val);
    }
    return NULL;
}

int main() {
    pthread_t prod[NPRODUCERS];
    pthread_t cons[NCONSUMERS];

    // create producers and consumers
    for (int i = 0; i < NPRODUCERS; i++)
        pthread_create(&prod[i], NULL, producer, NULL);
    
    for (int i = 0; i < NCONSUMERS; i++)
        pthread_create(&cons[i], NULL, consumer, NULL);

    // join all producers and consumers
    for (int i = 0; i < NPRODUCERS; i++)
        pthread_join(prod[i], NULL);

    for (int i = 0; i < NCONSUMERS; i++)
        pthread_join(cons[i], NULL);

    printf("the enddddddd. Total Consumed: %d\n", total_consumed);
    return 0;
}


/*
 * The main function takes a command line argument of type int, call it N.
 * It should launch N threads, each should run hello().
 * Main thread should wait for all threads to end before exiting.
 *
 * CAN'T USE GLOBAL VARIABLES.
 */


#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

void* hello (void* p) {
	printf("Hello world from child thread!\n");
	return NULL;
}

int main(int argc, char *argv[]) {

    if (argc<2) {
        fprintf(stderr, "In sufficient argumetns. Usage: ./a.out  NUMTHREADS\n");
        exit(1);
    }

    int N = atoi(argv[1]);
    printf("main() recieved arg: %d\n", N);

    /*
     * YOUR IMPLEMENTATION GOES HERE
     * ADD ANY HELPERS FUNCTIONS YOU NEED
     */

     pthread_t *tids = malloc(sizeof(pthread_t)*N);
     for(int i=0; i<N; i++)
         pthread_create(&tids[i], NULL, hello, NULL);

     for(int i=0; i<N; i++)
         pthread_join(tids[i], NULL);

    printf("bye from main thread\n");

    free(tids);
  return 0;
}



/*
 * make_array_random(long size):
 *   dynamically allocates an array of "size" integers
 *   initialiezes the array with random values less than MODULO
 *   returns the address of this initialized array
 *
 * find_array(long *arr, long size, int val):
 *   searches for the value "val" in the array "arr"
 *   returns the index of element where value "val" is found, otherwise -1
 *   if there are multiple instances of value "val", returns the last index
 *
 *
 * Task:
 *   your job is to implement the functionality of find_array_thread() which
 *   does behaves exactly the same as find_array() but would be run
 *   in a separate thread. You'll, of course have to create that thread in
 *   main() and pass any data needed by the thread. The thread will return
 *   the index where it finds the value "val" or -1, which the main thread
 *   will then print.
 *
 *   CAN'T USE GLOBAL VARIABLES.

*/



#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N 1000000000
#define MODULO 100000000

typedef struct thread_data {
    int *arr;
    int val;
    int len;
} tdata;

int * make_array_random(long size) {

    srand(time(NULL));

    int * arr = malloc(size*sizeof(long));
    if (arr==NULL) exit(-1);

    for(long i=0; i<size; i++)
        arr[i] = rand()%MODULO;

    return arr;
}


int find_array(int *arr, long size, int val) {
    int idx = -1;
    for(long i=0; i<size; i++)
      if (arr[i]==val)
        idx = i;

    return idx;
}


void *find_array_thread(void *arg) {

    /*
     * your implementation goes here.
     * create any helper functions you might need.
     */

     int idx = -1;
     tdata *t = (tdata *)arg;
     for(int i=0; i<t->len; i++)
         if (t->arr[i]==t->val)
             idx = i;

     int *retval = malloc(sizeof(int));
     *retval = idx;
    return (void *)retval;
}

int main() {

    int * arr = make_array_random(N);

    // value to search
    int val = rand()%MODULO;

    int idx1 = find_array(arr, N, val);
    printf("find_array found val=%d at index=%d\n", val, idx1);


    int idx2 = -1;
    tdata t = {.arr=arr, .val=val, .len=N};

    /*
     * YOUR IMPLEMANTATION GOES HERE.
     * ADD ANY HELPER FUNCTIONS NEEDED.
     */
    pthread_t tid;
    pthread_create(&tid, NULL, find_array_thread, &t);

    int *result = malloc(sizeof(int));
    pthread_join(tid, (void**)&result);
    idx2 = *result;

    printf("using a separate thread found val=%d at index=%d\n", val, idx2);

    free(result);
    free(arr);
    return 0;
}


/*
 * make_array_random(long size):
 *   dynamically allocates an array of "size" integers
 *   initialiezes the array with random values less than MODULO
 *   returns the address of this initialized array
 *
 * find_array(long *arr, long size, int val):
 *   searches for the value "val" in the array "arr"
 *   returns the index of element where value "val" is found, otherwise -1
 *   if there are multiple instances of value "val", returns the last index
 *
 *
 * Task:
 *   your job is to implement the function find_array_parallel() which
 *   does behaves exactly the same as find_array() but does so in parallel
 *   by dividing the search task among NTHREADS threads.
 *
 *   CAN'T USE GLOBAL VARIABLES.

*/



#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define N 1000000000
#define NTHREADS 8
#define MODULO 100000000

long * make_array_random(long size) {

    srand(time(NULL));

    long * arr = malloc(size*sizeof(long));
    if (arr==NULL) exit(-1);

    for(long i=0; i<size; i++)
        arr[i] = rand()%MODULO;

    return arr;
}

int find_array(long *arr, long size, int val) {
    int idx = -1;
    for(long i=0; i<size; i++)
      if (arr[i]==val)
        idx = i;

    return idx;
}

typedef struct thread_info {
    int val;
    long * start;
    long size;
} thread_info;


void * partial_find_array(void *p) {
    thread_info * ip = (thread_info *)p;
    int idx = -1;
    for(long i=0; i<ip->size; i++)
      if(ip->start[i] == ip->val)
        idx = i;

    long * retp = malloc(sizeof(int));
    *retp = idx;
    return retp;
}

int find_array_parallel(long *arr, long size, int val) {
    pthread_t tid[NTHREADS];
    thread_info info[NTHREADS];
    for (long i=0; i<NTHREADS; i++) {
        info[i].val = val;
        info[i].size = size/NTHREADS;
        info[i].start = arr + i*(size/NTHREADS);
    }
    for(long i=0; i<NTHREADS; i++)
        pthread_create(&tid[i], NULL, partial_find_array, &info[i]);

    void *retp = NULL;
    int idx = -1;
    for(long i=0; i<NTHREADS; i++) {
        pthread_join(tid[i], (void **)&retp);
    	idx = *(int*)retp;
    	if(idx != -1)
            idx = i*(size/NTHREADS) + idx;
        free(retp);
    }

    return idx;
}

int main() {

    struct timeval start_time, end_time;
    long seconds, microseconds;
    double elapsed_time;

    long * arr = make_array_random(N);

    int val = rand()%MODULO;

    gettimeofday(&start_time, NULL);
    int idx1 = find_array(arr, N, val);
    gettimeofday(&end_time, NULL);
    seconds = end_time.tv_sec - start_time.tv_sec;
    microseconds = end_time.tv_usec - start_time.tv_usec;
    elapsed_time = seconds + microseconds / 1000000.0;
    printf("find_array found val=%d at index=%d using %lf seconds\n", val, idx1, elapsed_time);

    gettimeofday(&start_time, NULL);
    int idx2 = find_array_parallel(arr, N, val);
    gettimeofday(&end_time, NULL);
    seconds = end_time.tv_sec - start_time.tv_sec;
    microseconds = end_time.tv_usec - start_time.tv_usec;
    elapsed_time = seconds + microseconds / 1000000.0;
    printf("sum_array_parallel round val=%d at index=%d using %lf seconds\n", val, idx2, elapsed_time);

    free(arr);
    return 0;
}
